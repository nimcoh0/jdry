package org.softauto.compiler;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.velocity.Template;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;

import java.io.*;
import java.nio.file.Files;
import java.util.*;

import static java.nio.charset.StandardCharsets.UTF_8;

public class Compiler {

    private static final org.apache.logging.log4j.Logger logger = org.apache.logging.log4j.LogManager.getLogger(Compiler.class);

    private VelocityEngine velocityEngine;
    private List<Object> additionalVelocityTools = Collections.emptyList();
    private static String templateDir;
    private String suffix = ".java";
    private String outputCharacterEncoding;

    private static ObjectNode discovery = new ObjectMapper().createObjectNode();

    private static ArrayNode steps = new ObjectMapper().createArrayNode();

    private static ObjectNode listeners = new ObjectMapper().createObjectNode();

    private static String name;

    private static String namespace;

    public static final Set<String> RESERVED_WORDS = new HashSet<>(
            Arrays.asList("abstract", "assert", "boolean", "break", "byte", "case", "catch", "char", "class", "const",
                    "continue", "default", "do", "double", "else", "enum", "extends", "false", "final", "finally", "float", "for",
                    "goto", "if", "implements", "import", "instanceof", "int", "interface", "long", "native", "new", "null",
                    "package", "private", "protected", "public", "return", "short", "static", "strictfp", "super", "switch",
                    "synchronized", "this", "throw", "throws", "transient", "true", "try", "void", "volatile", "while",
                    /* classnames use internally by the avro code generator */
                    "Builder"));


    private static final Set<String> ERROR_RESERVED_WORDS = new HashSet<>(Arrays.asList("message", "cause"));

    private static final String FILE_HEADER = "/**\n" + " * Autogenerated by Avro\n" + " *\n"
            + " * DO NOT EDIT DIRECTLY\n" + " */\n";



    static final JsonFactory FACTORY = new JsonFactory();
    static final ObjectMapper MAPPER = new ObjectMapper(FACTORY);

    public static void setTemplateDir(String path){
        Compiler.templateDir = System.getProperty("org.apache.avro.specific.templates",
                path);
    }

    static {
        FACTORY.enable(JsonParser.Feature.ALLOW_COMMENTS);
        FACTORY.setCodec(MAPPER);
    }

    public Compiler(){
        if(templateDir == null){
           this.templateDir = System.getProperty("org.apache.avro.specific.templates",
              "jdry-compiler/src/main/resources/velocity/");
        }

        initializeVelocity();
        logger.debug("set templateDir to " +templateDir);
    }

    private void initializeVelocity() {
        this.velocityEngine = new VelocityEngine();

        // These properties tell Velocity to use its own classpath-based
        // loader, then drop down to check the root and the current folder
        velocityEngine.addProperty("resource.loaders", "class, file");
        velocityEngine.addProperty("resource.loader.class.class",
                "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader");
        velocityEngine.addProperty("resource.loader.file.class",
                "org.apache.velocity.runtime.resource.loader.FileResourceLoader");
        velocityEngine.addProperty("resource.loader.file.path", "/, .");
        velocityEngine.setProperty("runtime.strict_mode.enable", true);
        //velocityEngine.addProperty("userdirective", "org.softauto.compiler.directive.Serialize");
        //velocityEngine.addProperty("userdirective", "org.softauto.compiler.directive.Deserialize");
        //velocityEngine.addProperty("userdirective", "org.softauto.compiler.directive.ValidateReturnType");
        // Set whitespace gobbling to Backward Compatible (BC)
        // https://velocity.apache.org/engine/2.0/developer-guide.html#space-gobbling
        velocityEngine.setProperty("parser.space_gobbling", "bc");
        //context.put("jdryTools", JdryVelocityTool.class);

    }

    public void setAdditionalVelocityTools(List<Object> additionalVelocityTools) {
        this.additionalVelocityTools = additionalVelocityTools;
    }

    static class OutputFile {
        String path;
        String contents;
        String outputCharacterEncoding;

        /**
         * Writes output to path destination directory when it is newer than src,
         * creating directories as necessary. Returns the created file.
         */
        File writeToDestination(File src, File destDir) throws IOException {
            File f = new File(destDir, path);
            if (src != null && f.exists() && f.lastModified() >= src.lastModified())
                return f; // already up to date: ignore
            f.getParentFile().mkdirs();
            Writer fw = null;
            FileOutputStream fos = null;
            try {
                if (outputCharacterEncoding != null) {
                    fos = new FileOutputStream(f);
                    fw = new OutputStreamWriter(fos, outputCharacterEncoding);
                } else {
                    fw = Files.newBufferedWriter(f.toPath(), UTF_8);
                }
                fw.write(FILE_HEADER);
                fw.write(contents);
            } finally {
                if (fw != null)
                    fw.close();
                if (fos != null)
                    fos.close();
            }
            return f;
        }
    }

    public static String mangle(String word) {
        return mangle(word, false);
    }

    /** Utility for template use. Adds a dollar sign to reserved words. */
    public static String mangle(String word, boolean isError) {
        return mangle(word, isError ? ERROR_RESERVED_WORDS : RESERVED_WORDS);
    }

    /** Utility for template use. Adds a dollar sign to reserved words. */
    public static String mangle(String word, Set<String> reservedWords) {
        return mangle(word, reservedWords, false);
    }

    /** Utility for template use. Adds a dollar sign to reserved words. */
    public static String mangle(String word, Set<String> reservedWords, boolean isMethod) {
        if (word.contains(".")) {
            // If the 'word' is really a full path of a class we must mangle just the
            // classname
            int lastDot = word.lastIndexOf(".");
            String packageName = word.substring(0, lastDot + 1);
            String className = word.substring(lastDot + 1);
            return packageName + mangle(className, reservedWords, isMethod);
        }
        if (reservedWords.contains(word) || (isMethod && reservedWords
                .contains(Character.toLowerCase(word.charAt(0)) + ((word.length() > 1) ? word.substring(1) : "")))) {
            return word + "$";
        }
        return word;
    }


    public static void compileStepsInterface(File src, File dest) throws IOException {
        compileSteps(new File[] { src }, dest);
    }


    public static void compileListenerInterface(File src, File dest) throws IOException {
        compileListeners(new File[] { src }, dest);
    }





    public static ArrayNode parseSteps(File file) throws IOException {
        return parseSteps(Compiler.FACTORY.createParser(file));
    }

    private static ArrayNode parseSteps(JsonParser parser) {
        try {
            parseSteps((JsonNode) Compiler.MAPPER.readTree(parser));
        } catch (IOException e) {
            e.printStackTrace();
        }
        return steps;
    }

    private static void parseSteps(JsonNode jsonNode){
        try {
            discovery.put("name",jsonNode.get("name").asText());
            discovery.put("namespace",jsonNode.get("namespace").asText());
            for(JsonNode node : jsonNode.get("methods")) {
                if(node.get("type").asText().equals("method")) {
                    ((ObjectNode) node).put("fullname", (node.get("namespce").asText() + "." + node.get("name").asText()).replace(".", "_"));
                    parseStep(node);
                }
            }
            discovery.set("steps",steps);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void parseStep(JsonNode node){
       steps.add(node);
    }

    public static void compileSteps(File[] srcFiles, File dest) throws IOException {
        for (File src : srcFiles) {
            ArrayNode steps = parseSteps(src);
            Compiler compiler = new Compiler();
            compiler.compileToSteps(src, dest);
            logger.debug("compile successfully " + src.getName());
        }

    }




    public static JsonNode parseListeners(File file) throws IOException {
        return parseListeners(Compiler.FACTORY.createParser(file));
    }

    private static JsonNode parseListeners(JsonParser parser) {
        try {
            parseListeners((JsonNode) Compiler.MAPPER.readTree(parser));
        } catch (IOException e) {
            e.printStackTrace();
        }
        return listeners;
    }

    private static void parseListeners(JsonNode jsonNode){
        try {
            discovery.put("name",jsonNode.get("name").asText());
            discovery.put("namespace",jsonNode.get("namespace").asText());
            for(JsonNode node : jsonNode.get("methods")) {
                if(node.get("type").asText().equals("listener")) {
                    ((ObjectNode) node).put("fullname", (node.get("namespce").asText() + "." + node.get("name").asText()).replace(".", "_"));
                    parseListener(node);
                }
            }
            discovery.set("listeners",listeners);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void parseListener(JsonNode node){
        listeners.set(node.get("namespce").asText()+"."+node.get("name").asText(),node);
    }

    public static void compileListeners(File[] srcFiles, File dest) throws IOException {
        for (File src : srcFiles) {
            JsonNode listeners = parseListeners(src);
            Compiler compiler = new Compiler();
            compiler.compileToListeners(src, dest);
            logger.debug("compile successfully " + src.getName());
        }

    }


    public void compileToSteps(File src, File dst) throws IOException {
        if (steps != null) {
            compileSteps(discovery).writeToDestination(src, dst);
        }
    }

    public void compileToListeners(File src, File dst) throws IOException {
        if (listeners != null) {
            compileListener(discovery).writeToDestination(src, dst);
        }
    }


    private String renderTemplate(String templateName, VelocityContext context) {
        Template template;
        try {

            template = this.velocityEngine.getTemplate(templateName);
        } catch (Exception e) {
            logger.error("fail rendering template ",e);
            throw new RuntimeException(e);
        }
        StringWriter writer = new StringWriter();
        template.merge(context, writer);
        logger.debug("render template successfully " + templateName);
        return writer.toString();
    }



    OutputFile compileSteps(JsonNode discovery) {
        VelocityContext context = new VelocityContext();
        context.put("discovery", discovery);
        context.put("this", this);
        for (Object velocityTool : additionalVelocityTools) {
            String toolName = velocityTool.getClass().getSimpleName().toLowerCase();
            context.put(toolName, velocityTool);
        }

        String out = renderTemplate(templateDir + "interface.vm", context);

        OutputFile outputFile = new OutputFile();
        String mangledName = mangle(discovery.get("name").asText()+"Service");
        outputFile.path = makePath(mangledName, discovery.get("namespace").asText());
        outputFile.contents = out;
        outputFile.outputCharacterEncoding = outputCharacterEncoding;
        logger.debug("write output to " + outputFile);
        return outputFile;
    }

    OutputFile compileListener(JsonNode discovery) {
        VelocityContext context = new VelocityContext();
        context.put("discovery", discovery);
        context.put("this", this);
        for (Object velocityTool : additionalVelocityTools) {
            String toolName = velocityTool.getClass().getSimpleName().toLowerCase();
            context.put(toolName, velocityTool);
        }

        String out = renderTemplate(templateDir + "listenerInterface.vm", context);

        OutputFile outputFile = new OutputFile();
        String mangledName = mangle(discovery.get("name").asText()+"ListenerService");
        outputFile.path = makePath(mangledName, discovery.get("namespace").asText());
        outputFile.contents = out;
        outputFile.outputCharacterEncoding = outputCharacterEncoding;
        logger.debug("write output to " + outputFile);
        return outputFile;
    }




    // package private for testing purposes
    String makePath(String name, String space) {
        if (space == null || space.isEmpty()) {
            return name + suffix;
        } else {
            return space.replace('.', File.separatorChar) + File.separatorChar + name + suffix;
        }
    }

    public static String javaEscape(String o) {
        if(o != null) {
            return o.replace("\\", "\\\\").replace("\"", "\\\"");
        }
        return null;
    }

    public static void main(String[] args) throws Exception {
        //loadConfiguration(args);
        logger.info("-------------- compile all ---------------- ");
        //compileSuite(new File(args[0]), new File(args[1]));
        compileStepsInterface(new File(args[0]), new File(args[1]));
        compileListenerInterface(new File(args[0]), new File(args[1]));
        logger.debug("input file "+ args[0]);
        logger.debug("output file "+ args[1]);
        logger.info("tests compile finsh successfully");
    }


    public static void compileListeners(String discovery,String output)throws Exception{
        logger.info("-------------- compile listeners ---------------- ");
        compileListenerInterface(new File(discovery), new File(output));
        logger.debug("input file "+ discovery);
        logger.debug("output file "+ output);
        logger.info("listeners compile finsh successfully");
    }

    public static void compileSteps(String discovery,String output)throws Exception{
        logger.info("-------------- compile steps  ---------------- ");
        compileStepsInterface(new File(discovery), new File(output));
        logger.debug("input file "+ discovery);
        logger.debug("output file "+ output);
        logger.info("Steps compile finsh successfully");
    }

    public void setOutputCharacterEncoding(String outputCharacterEncoding) {
        this.outputCharacterEncoding = outputCharacterEncoding;
    }

    public String capitalizeFirstLetter(String str){
        return str.toUpperCase().charAt(0)+str.substring(1,str.length());
    }

    public String unCapitalizeFirstLetter(String str){
        return str.toLowerCase().charAt(0)+str.substring(1,str.length());
    }

    public static String getJavaStringFullName(String str){
        return str.replace(".","_");
    }

    public static boolean isPrimitive(String name){
        String str = name;
        if(name.contains(".")){
            str = name.substring(name.lastIndexOf(".")+1);
        }

        if(PRIMITIVES.contains(str)){
            return true;
        }
        return false;
    }

    static final List<String> PRIMITIVES = new ArrayList<>();
    static {
        //PRIMITIVES.add("string");
        PRIMITIVES.add("bytes");
        PRIMITIVES.add("int");
        //PRIMITIVES.add("integer");
        PRIMITIVES.add("long");
        PRIMITIVES.add("float");
        PRIMITIVES.add("double");
        PRIMITIVES.add("boolean");
        PRIMITIVES.add("void");
    }

    public String primitiveToObject(String type){
        try {
            if(type.equals("void")){
                return "Void";
            }
            Class c = ClassUtils.getClass(type);
            return ClassUtils.primitiveToWrapper(c).getTypeName();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }
}
